import std::sv::{ SV }
import std::compact_map::{ Map }
import std::vector::{ Vector }
import .common::{ Grid }
import std::traits::hash::pair_hash

struct Vec2 {
    x: i32
    y: i32
}

def Vec2::hash(this): u32 => pair_hash(.x.hash(), .y.hash())
def Vec2::eq(this, other: Vec2): bool => .x == other.x and .y == other.y

struct State {
    pos: Vec2
    dir: Vec2
}

def State::hash(this): u32 => pair_hash(.pos.hash(), .dir.hash())
def State::eq(this, other: State): bool => .pos.eq(other.pos) and .dir.eq(other.dir)

def is_valid(grid: &Grid, pos: Vec2): bool {
    if pos.x < 0 or pos.x >= grid.width as i32 then return false
    if pos.y < 0 or pos.y >= grid.height as i32 then return false
    return true
}

struct Hit {
    state: State
    seen: &Vector<Vec2>
}

// This is the global cache which stores the next mirror we hit for a given state
// Only used for states where we are on a '.' cell
let next_map: &Map<State, Hit>

let seen_pos: &Map<Vec2, bool>
let seen_state: &Map<State, bool>
let next: &Vector<State>

def num_energized_cells(grid: &Grid, start_pos: Vec2, start_dir: Vec2): u64 {
    // Note: Don't clear the cache here, we want to reuse it across calls
    seen_pos.clear()
    seen_state.clear()
    next.clear()

    next.push(State(start_pos, start_dir))
    while next.size > 0 {
        let st = next.unchecked_pop()
        let pos = st.pos
        let dir = st.dir

        if not is_valid(grid, pos) then continue

        if seen_state.contains(st) continue
        seen_state.insert(st, true)
        seen_pos.insert(pos, true)

        let c = grid.at(pos.x as u32, pos.y as u32)
        match c {
            '\\' => dir = Vec2(dir.y, dir.x)
            '/' => dir = Vec2(-dir.y, -dir.x)
            '|' => {
                if dir.y == 0 {
                    next.push(State(Vec2(pos.x, pos.y-1), Vec2(0, -1)))
                    next.push(State(Vec2(pos.x, pos.y+1), Vec2(0,  1)))
                    continue
                }
            }
            '-' => {
                if dir.x == 0 {
                    next.push(State(Vec2(pos.x-1, pos.y), Vec2(-1, 0)))
                    next.push(State(Vec2(pos.x+1, pos.y), Vec2( 1, 0)))
                    continue
                }
            }
            else => {
                let item = next_map.get_item(st)
                // We've been here before, no need to loop until the next mirror
                let hit = if item? {
                    yield item.value

                // Find the nodes till the next mirror, and cache them
                } else {
                    let seen = Vector<Vec2>::new()
                    while true {
                        pos = Vec2(pos.x + dir.x, pos.y + dir.y)
                        if not is_valid(grid, pos) or grid.at(pos.x as u32, pos.y as u32) != '.' {
                            break
                        }
                        seen.push(pos)
                    }
                    let next_state = State(pos, dir)
                    let hit = Hit(next_state, seen)
                    next_map.insert(st, hit)
                    yield hit
                }

                for let i = 0; i < hit.seen.size; i++ {
                    seen_pos.insert(hit.seen.at(i), true)
                }
                next.push(hit.state)
                continue
            }
        }

        let next_pos = Vec2(pos.x + dir.x, pos.y + dir.y)
        next.push(State(next_pos, dir))
    }

    return seen_pos.size() as u64
}

def part_one(grid: &Grid): u64 => num_energized_cells(grid, Vec2(0, 0), Vec2(1, 0))

def part_two(grid: &Grid): u64 {
    let N = grid.width as i32

    let mx = 0u64
    for let i = 0i32; i < N; i++ {
        mx = mx.max(num_energized_cells(grid, Vec2(  i,   0), Vec2( 0,  1)))
        mx = mx.max(num_energized_cells(grid, Vec2(  i, N-1), Vec2( 0, -1)))
        mx = mx.max(num_energized_cells(grid, Vec2(  0,   i), Vec2( 1,  0)))
        mx = mx.max(num_energized_cells(grid, Vec2(N-1,   i), Vec2(-1,  0)))
    }
    return mx
}

def main(argc: i32, argv: &str) {
    assert argc > 1, `Usage: {argv[0]} <input file>`
    let sv = SV::from_file(argv[1])

    next_map = Map<State, Hit>::new(capacity: 4096)
    seen_pos = Map<Vec2, bool>::new(capacity: 4096)
    seen_state = Map<State, bool>::new(capacity: 4096)
    next = Vector<State>::new(capacity: 4096)

    let grid = Grid::make(sv)

    println(`Part 1: {part_one(&grid)}`)
    println(`Part 2: {part_two(&grid)}`)
}